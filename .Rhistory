# 11)
zippydidoo <- "https://d396qusza40orc.cloudfront.net/rprog/data/quiz1_data.zip"
connekt <- unz(zippydidoo, filename = "quiz1_data.zip", open = "r")
quizfile <- read.csv("hw1_data")
getwd()
quizfile <- read.csv("hw1_data.csv")
head(quizfile)
glimpse(quizfile)
quizfile[, 1:2]
quizfile[1:2, ]
quizfile[1:2, ]
# 13)
length(quizfile)
# 13)
length(quizfile[, 1])
# 14)
quizfile[-1:2, ]
# 14)
quizfile[-1, ]
# 14)
quizfile[152:153, ]
quizfile[-nrow(1:2)]
# 15)
quizfile[47, "Ozone"]
quizfile[47, 1]
# 16)
liamniesonsmissingdaughter <- is.na(quizfile[, 1])
liamniesonsmissingdaughter
rm(liamniesonsmissingdaughter)
# 16)
liamneesonsmissingdaughter <- is.na(quizfile[, 1])
liamneesonsmissingdaughter
153 - sum(liamneesonsmissingdaughter)
sum(liamneesonsmissingdaughter)
# 17)
mean(quizfile$Ozone, na.rm = T)
mean(quizfile$Ozone)
# 18)
q18subset <- quizfile[quizfile$Ozone > 31]
# 18)
q18subset <- quizfile[Ozone > 31]
# 18)
q18subset <- quizfile[quizfile$Ozone > 31]
quizfile[quizfile$Ozone > 31]
# 18)
q18subset <- quizfile[quizfile$Ozone > 31, ]
# 18)
q18subset <- quizfile[quizfile$Ozone > 31 && quizfile$Temp > 90, ]
mean(q18subset$Solar.R, na.rm = T)
q18subset
# 18)
q18subset <- quizfile[quizfile$Ozone > 31, ]
q18subset
# 18)
q18subset <- quizfile[quizfile$Ozone > 31 & quizfile$Temp > 90, ]
q18subset
mean(q18subset$Solar.R, na.rm = T)
# 19)
q19subset <- quizfile[quizfile$Month == 6]
# 19)
q19subset <- quizfile[quizfile$Month == 6, ]
mean(q19subset$Temp, na.rm = T)
# 79.1
# OR
mean(quizfile$Temp[quizfile$Month == 6, ], na.rm = T)
# 79.1
# OR
mean(quizfile[quizfile$Month == 6, ]$Temp, na.rm = T)
# 20)
max(quizfile[quizfile$Month == 5, ]$Ozone, na.rm = T)
print(i)
# most basic
for(i in 1:10) {
print(i)
}
x <- c("a", "b", "c", "d")
for(i in 1:4) {
print(x[1])
}
for(i in seq_along(x)) {
print(x[i])
}
for(letter in x) {
print(letter)
}
for(i in 1:4) print(x[i])
x <- matrix(1:6, 2, 3)
for(i in seq_len(nrow(x))) {
for(j in seq_len(ncol(x))) {
print(x[i, j])
}
}
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if(coin == 1) { ## random walk
z <- z + 1
} else {
z <- z - 1
}
}
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if(coin == 1) { ## random walk
z <- z + 1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if(coin == 1) { ## random walk
z <- z + 1
} else {
z <- z - 1
}
}
z <- 5
while(z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if(coin == 1) { ## random walk
z <- z + 1
} else {
z <- z - 1
}
}
add_two <- function(x, y) { ## don't forget to specify the arguments!
x + y
}
add_two(4, 5)
above
above <- function(x, n) {
use <- x > n
x[use]
}
x <- 1:20
above(x, 12)
above(x)
above <- function(x, n = 10) {
use <- x > n
x[use]
}
above(x)
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
mean[i] <- mean(y[, i])
}
means
}
columnmean(airquality)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
mean[i] <- mean(y[, i])
}
means
}
columnmean(airquality)
mean[i] <- mean(y[, i], na.rm = removeNA)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
mean[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(airquality)
load(airquality)
airquality
mean(i) <- mean(y[, i], na.rm = removeNA)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
mean(i) <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(airquality)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(airquality)
/help rnorm
\help rnorm
help(rnorm)
# R functions arguments can be matches positionally or by name
#   following calls to 'sd' are all equivalent
mydata <- rnorm(100) ## 100 random observations
sd(mydagta)
sd(mydata)
sd(x = mydata)
x
sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata)
sd(na.rm = FALSE, mydata)
# Mixing 'positional' matching and matching 'by name'
# by default, the argument list of a function dictates the order in which arguments are to be entered
args(lm)
default_arg_list <- lm(y ~ x, mydata, 1:100, model = FALSE)
# R functions arguments can be matches positionally or by name
#   following calls to 'sd' are all equivalent
mydata <- rnorm(100) ## 100 random observations following normal distribution
default_arg_list <- lm(y ~ x, mydata, 1:100, model = FALSE)
default_arg_list <- lm(y~x, mydata, 1:100, model = FALSE)
lm(y~x, mydata, 1:100, model = FALSE)
# but, specifying an argument by name pulls it out of the default order
lm(data = mydata, y~x, model = FALSE, 1:100)
return(theThing)
# e.g.
f <- function(a, b = 1, c = 2, d = NULL) {
theThing <- a * b + 2 + d
return(theThing)
}
f(a = 4, d = 7)
f()
f(a = 4)
f(a = 5)
f(a = 5, d)
f(a = 5, d = 8)
f2 <- function(a, b) {
a ^ 2
}
f2(2)
f3 <- function(a, b) {
print(a)
print(b)
}
f(45)
f3(45)
# some functions, e.g. paste(), can operate with a variable number of arguments
# when you don't know the number of arguments in advance, can also use '...'
args(paste)
args(cat)
paste("a", "b", sep = ":")
paste("a", "b", se = ":")
f4 <- function(x) {x * x}
f4
lm <- function(x) {x * x}
lm
# lm is a default function in R
# above example assigns a new function to 'lm'
# how does R decide whether you mean the linear-model lm or the x * x lm?
#     R binds value to a symbol
#     searches through a series of 'environments' to find match
#     generally, in command line, the search order is
#         1. search global environment
#         2. search namespaces of each of the packages on search list
# search list is found by
search()
lm(3)
# Order of search packages matters!
#     by default, global environment or user's workspace is always first element of search list
#     'base' package is always the last
#     User can configure which packages get loaded on startup
#     loading a package with 'library' puts the namespace of that package on the searchlist
#     e.g.
library(tidyverse)
# Order of search packages matters!
#     by default, global environment or user's workspace is always first element of search list
#     'base' package is always the last
#     User can configure which packages get loaded on startup
#     loading a package with 'library' puts the namespace of that package on the searchlist
#     e.g.
library(dplyr)
install.packages("dplyr")
# lm is a default function in R
# above example assigns a new function to 'lm'
# how does R decide whether you mean the linear-model lm or the x * x lm?
#     R binds value to a symbol
#     searches through a series of 'environments' to find match
#     generally, in command line, the search order is
#         1. search global environment
#         2. search namespaces of each of the packages on search list
# search list is found by
search()
# Order of search packages matters!
#     by default, global environment or user's workspace is always first element of search list
#     'base' package is always the last
#     User can configure which packages get loaded on startup
#     loading a package with 'library' puts the namespace of that package on the searchlist
#     e.g.
library(dplyr)
search()
make.power <- function(n) {
pow <- function(x) {
x ^ n
}
pow
}
cube <- make.power(3)
square <- make.power(2)
cube(3)
square(2)
cube(2)
square(2)
ls(environment(cube))
get("n", environment(cube))
ls(environment(square))
get("n", environment(square))
get("pow", environment(square))
f <- function(x) {
y <- 2
y ^ 2 + g(x)
}
x * y
f <- function(x) {
y <- 2
y ^ 2 + g(x)
}
g <- function(x){
x * y
}
f(3)
y <- 10
f <- function(x) {
y <- 2
y ^ 2 + g(x)
}
g <- function(x){
x * y
}
f(3)
# creating and then calling a function in the global environment can create the illusion of dynamic scoping
# e.g.
g <- function(x){
a <- 3
x + a + y
}
g(2)
g(2)
x
y <- 3
g(2)
install.packages("usethis")
library(usethis)
temp = list.files("C:\Users\O\Desktop\R\oleg_repository\specdata", pattern="*.csv")
temp = list.files("C:/Users/O/Desktop/R/oleg_repository/specdata", pattern="*.csv")
myfiles = lapply(temp, read.delim)
temp
help("ldply")
help("lapply")
myfiles = lapply(temp, read.csv)
temp = list.files("C:/Users/O/Desktop/R/oleg_repository/specdata",
pattern="*.csv",
full.names = TRUE)
myfiles = lapply(temp, read.csv)
myfiles
myfiles$1
View(myfiles)
View(myfiles)
View(myfiles$[[1]])
View(myfiles[[1]])
myfiles[[1]]
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
filename <- vector(mode="character", length=length(id))
for(i in seq_along(id)) {
x <- id[i]
id_string <- toString(x)
if (x >= 1 && x <= 9) {
monitor <- paste("00", id_string, ".csv", sep="")
}
else if (x >= 10 && x <= 99) {
id_string <- toString(x)
monitor <- paste("0", id_string, ".csv", sep="")
}
else {
id_string <- toString(x)
monitor <- paste(id_string, ".csv", sep="")
}
filename[i] <- monitor
#print(monitor)
}
accumulator <- 0
total <- 0
for(i in filename) {
airquality <- read.csv(i)
good <- complete.cases(airquality[pollutant])
#good <- complete.cases(airquality[[pollutant]])
airquality <- airquality[good, ]
total <- total + nrow(airquality)
#accumulator <- accumulator + sum(airquality[pollutant], na.rm = TRUE)
# We need [[]] around pollutant instead of [] since airquality[pollutant]
# is a data.frame but we need a vector here. Please note that using either
#[[]] or [] gives the same results as the test cases but only [[]] successfully
#passes the submit() script
accumulator <- accumulator + sum(airquality[[pollutant]], na.rm = TRUE)
}
accumulator/total
}
args(pollutantmean)
specdata <- "C:/Users/O/Desktop/R/oleg_repository/specdata"
pollutantmean(specdata, nitrate, 1:45)
myfiles[[1]]$sulfate
mean(myfiles[[1]]$sulfate, na.rm = T)
rm(temp)
temp
rm(myfiles)
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
## NOTE: Do not round the results!
the_files = list.files("C:/Users/O/Desktop/R/oleg_repository/specdata",
pattern="*.csv",
full.names = TRUE)
values = numeric()
for (i in id) {
data <- read.csv(the_files[i])
values <- c(values, data[["pollutant"]])
}
mean(values, na.rm)
}
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
## NOTE: Do not round the results!
the_files = list.files(path = directory,
pattern ="*.csv",
full.names = TRUE)
values = numeric()
for (i in id) {
data <- read.csv(the_files[i])
values <- c(values, data[["pollutant"]])
}
mean(values, na.rm)
}
specdata <- "C:/Users/O/Desktop/R/oleg_repository/specdata"
pollutantmean(specdata, sulfate, 1:10)
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
## NOTE: Do not round the results!
the_files = list.files(path = directory,
pattern ="*.csv",
full.names = TRUE)
values = numeric()
for (i in id) {
data <- read.csv(the_files[i])
values <- c(values, data[["pollutant"]])
}
mean(values, na.rm = T)
}
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean <- function(directory, pollutant, id = 1:332) {
## 'directory' is a character vector of length 1 indicating
## the location of the CSV files
## 'pollutant' is a character vector of length 1 indicating
## the name of the pollutant for which we will calculate the
## mean; either "sulfate" or "nitrate".
## 'id' is an integer vector indicating the monitor ID numbers
## to be used
## Return the mean of the pollutant across all monitors list
## in the 'id' vector (ignoring NA values)
## NOTE: Do not round the results!
the_files = list.files(path = directory,
pattern ="*.csv",
full.names = TRUE)
values = numeric()
for (i in id) {
data <- read.csv(the_files[i])
values <- c(values, data[[pollutant]])
}
mean(values, na.rm = T)
}
pollutantmean("specdata", "sulfate", 1:10)
pollutantmean("specdata", "nitrate", 1:10)
pollutantmean("specdata", "nitrate", 70:72)
pollutantmean("specdata", "nitrate", 23)
