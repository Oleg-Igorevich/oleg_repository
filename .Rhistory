1,500,500
1 500 500 + 2
1500500 + 2
#     - use the colClasses argument. This can make function up to 2x faster.
#       - but to do this, you need know the calss of each column in data frame
#       - e.g. all columns numeric, so colClasses = "numeric"
#       - to quickly figure out classes of each column:
#         - initial <- read.table("datatable.txt", nrows = 100)
#         - classes <- sapply(initial, class)
#         - tabAll <- read.table("datatable.txt", colClasses = classes)
# OOOOOH, and the math now!
# e.g. 1,500,000 rows; 120 columns
# 1,500,000 * 120 * 8 bytes/numeric
1500000 * 120 * 8
y <- data.frame(a = 1, b = "a")
View(y)
dput(y)
dput(y, file = "y.R")
new.y <- dget("y.R")
View(new.y)
# dump is similar to dput, but can be used to save multiple objects
# dump
# source
x <- "foo"
y <- data.frame(a = 1, b = "a")
dump(c("x", "y"), file = "data.R")
rm(x, y)
source("data.R")
y
x
# file <- opens a connection to a file
str(file)
con <- url("http://www.jhsph.edu", "r")
x <- readLines(con)
head(x)
x[1]
# number of operators can be used to extract subsets of R objects
# [ always returns object of same class; can select more than one element (one exception)
# [[ used to extract elements of a list or data frame; can be used to extract
#   single element and class of returned object need not be a list or data frame
# $ used to extract elements of a list or data frame by name
x <- c("a", "b", "c", "d", "e", "f", "g")
x[1]
x[2]
x[1:4]
x[x > "a"] # relies of lexigraphical order - ooh-la-la
u <- x > "a"
u
x[u]
x <- list(foo = 1:4, bar = 0.6)
x[1]
$foo
x$foo
x[[1]]
x$bar
x[["bar"]]
x[1]
x$bar
x[1]
x["bar"]
x[c(1, 2)]
x[(1:4)]
x[(1:2)]
x[c(1, 2)] = x[(1:2)]
x[c(1, 2)] == x[(1:2)]
# so, can't use double-bracket or $ to extract multiple elements of a list
# BUT
# double-bracket can be used with computed indices
name <- "foo"
x[[name]]
x$name
x$foo
# double-bracket can take an integer sequence
x <- list(a = list(10, 12, 14), b = c(3.14, 2.81))
x[[c(1, 3)]]
x[[c(1, 1)]]
x[[c(1, 2)]]
x[[1]][[3]]
x[[c(2, 1)]]
x[[c(1, 2)]]
x <- matrix(1:6, 2, 3)
x
x[1, 2]
x[2, 1]
x[1,]
x[,1]
x[1, 2, drop = FALSE]
x[1, 2]
x[1, 2, drop = FALSE]
x[1,]
x[1, , drop = F]
x <- list(aardvark = 1:5)
x$a
above case, the $ looks for a name that matches the first element specified
# BUT
# x[["a"
# in the above case, the $ looks for a name that matches the first element specified
# BUT
x[["a"]]
# double-bracket doesn't do partial matching
# but there is a secondary argument
x[["a", exact = FALSE]]
x <- c(1, 2, NA, 4, NA, 5)
bad <- is.na(x)
bad
x[!bad]
# ! is "bang operator"
# multiple objects with missing values:
x <- x
y <- c("a", "b", NA, "d", NA, "f")
good <- complete.cases(x, y)
good
x[good]
y[good]
z <- c(4, NA, 8, NA, 7, 9)
m1 <- rbind(x, z)
m1
good <- complete.cases(m1)
good
m1[good, ][1:6, ]
m1[good, ]
z <- c(4, 5, 8, NA, 7, 9)
m1 <- rbind(x, z)
good <- complete.cases(m1)
good
m1[good, ]
m1[good, ][1:2]
m1[good, ][1:2, ]
m1
m1[, good][, 1:6]
m1[, good]
z <- c(4, 5, 8, 6, 7, 9)
m1 <- rbind(x, z)
good <- complete.cases(m1)
good
m1[, good]
x <- c(1, 2, NA, 4, NA, 5)
z <- c(4, 5, 8, 6, 7, 9)
m1 <- rbind(x, z)
m1
good <- complete.cases(m1)
good
m1[, good]
x <- c(1, 2, NA, 4, NA, 5)
z <- c(4, 5, 8, 6, 7, 9)
m1 <- rbind(x, z)
m1 <- cbind(x, z)
m1
good <- complete.cases(m1)
good
m1[, good]
m1[good, ][1:6, ]
m1[good, ]
m1[good, ][1:4, ]
m1[good, ][1:3, ]
x <- 1:4; y <- 6:9
x + y
x > 2
x >= 2
y == 8
x * y
x / y
x <- matrix(1:4, 2, 2); y <- matrix(rep(10, 4), 2, 2)
x
y
x * y
x / y
x %*% y # true matrix multiplication - muah-ha-ha
x <- 4
str(x)
x <- c(4, "a", TRUE)
x
str(x)
x <- list(2, "a", "b", TRUE)
x[[1]]
y <- x[[1]]
y
str(y)
x <- 1:4
x
y <- 2
x + 2
str(x + y)
# 10) have x <- c(3, 5, 1, 10, 12, 6) and want to set all elements of this vector
#     that are less than 6 to be equal to zero, what's the code?
x <- c(3, 5, 1, 10, 12, 6)
x[x >= 6] <- 0
x
x[x =< 6] <- 0
x[x <= 6] <- 0
x
# 10) have x <- c(3, 5, 1, 10, 12, 6) and want to set all elements of this vector
#     that are less than 6 to be equal to zero, what's the code?
x <- c(3, 5, 1, 10, 12, 6)
x[x <= 6] <- 0
x
# 10) have x <- c(3, 5, 1, 10, 12, 6) and want to set all elements of this vector
#     that are less than 6 to be equal to zero, what's the code?
x <- c(3, 5, 1, 10, 12, 6)
x[x < 6] <- 0
x
# 11)
zippy-di-doo <- "https://d396qusza40orc.cloudfront.net/rprog/data/quiz1_data.zip"
# 11)
zippydidoo <- "https://d396qusza40orc.cloudfront.net/rprog/data/quiz1_data.zip"
connekt <- unz(zippydidoo, filename = "quiz1_data.zip", open = "r")
quizfile <- read.csv("hw1_data")
getwd()
quizfile <- read.csv("hw1_data.csv")
head(quizfile)
glimpse(quizfile)
quizfile[, 1:2]
quizfile[1:2, ]
quizfile[1:2, ]
# 13)
length(quizfile)
# 13)
length(quizfile[, 1])
# 14)
quizfile[-1:2, ]
# 14)
quizfile[-1, ]
# 14)
quizfile[152:153, ]
quizfile[-nrow(1:2)]
# 15)
quizfile[47, "Ozone"]
quizfile[47, 1]
# 16)
liamniesonsmissingdaughter <- is.na(quizfile[, 1])
liamniesonsmissingdaughter
rm(liamniesonsmissingdaughter)
# 16)
liamneesonsmissingdaughter <- is.na(quizfile[, 1])
liamneesonsmissingdaughter
153 - sum(liamneesonsmissingdaughter)
sum(liamneesonsmissingdaughter)
# 17)
mean(quizfile$Ozone, na.rm = T)
mean(quizfile$Ozone)
# 18)
q18subset <- quizfile[quizfile$Ozone > 31]
# 18)
q18subset <- quizfile[Ozone > 31]
# 18)
q18subset <- quizfile[quizfile$Ozone > 31]
quizfile[quizfile$Ozone > 31]
# 18)
q18subset <- quizfile[quizfile$Ozone > 31, ]
# 18)
q18subset <- quizfile[quizfile$Ozone > 31 && quizfile$Temp > 90, ]
mean(q18subset$Solar.R, na.rm = T)
q18subset
# 18)
q18subset <- quizfile[quizfile$Ozone > 31, ]
q18subset
# 18)
q18subset <- quizfile[quizfile$Ozone > 31 & quizfile$Temp > 90, ]
q18subset
mean(q18subset$Solar.R, na.rm = T)
# 19)
q19subset <- quizfile[quizfile$Month == 6]
# 19)
q19subset <- quizfile[quizfile$Month == 6, ]
mean(q19subset$Temp, na.rm = T)
# 79.1
# OR
mean(quizfile$Temp[quizfile$Month == 6, ], na.rm = T)
# 79.1
# OR
mean(quizfile[quizfile$Month == 6, ]$Temp, na.rm = T)
# 20)
max(quizfile[quizfile$Month == 5, ]$Ozone, na.rm = T)
